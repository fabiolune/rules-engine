{
  "api/LogicEngine.CompiledCatalog-1.html": {
    "href": "api/LogicEngine.CompiledCatalog-1.html",
    "title": "Class CompiledCatalog<T> | Logic Engine",
    "keywords": "Class CompiledCatalog<T> Namespace LogicEngine Assembly LogicEngine.dll public record CompiledCatalog<T> : IAppliable<T>, IDetailedAppliable<T, IEnumerable<string>>, IAppliedSelector<T, string>, IEquatable<CompiledCatalog<T>> where T : new() Type Parameters T Inheritance object CompiledCatalog<T> Implements IAppliable<T> IDetailedAppliable<T, IEnumerable<string>> IAppliedSelector<T, string> IEquatable<CompiledCatalog<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompiledCatalog(CompiledRulesSet<T>[], string) Creates a new compiled catalog public CompiledCatalog(CompiledRulesSet<T>[] ruleSets, string name) Parameters ruleSets CompiledRulesSet<T>[] name string Properties Name public string Name { get; } Property Value string Methods Apply(T) Applies the catalog to an item by looping over the rules sets public bool Apply(T item) Parameters item T Returns bool DetailedApply(T) Applies the catalog to an item and returns either a list of strings (the codes of the rules that are not satisfied) or a unit public Either<IEnumerable<string>, Unit> DetailedApply(T item) Parameters item T Returns Either<IEnumerable<string>, Unit> FirstMatching(T) Returns the code of the first rule that is satisfied by the item, None if no rule is satisfied public Option<string> FirstMatching(T item) Parameters item T Returns Option<string>"
  },
  "api/LogicEngine.CompiledRule-1.html": {
    "href": "api/LogicEngine.CompiledRule-1.html",
    "title": "Class CompiledRule<T> | Logic Engine",
    "keywords": "Class CompiledRule<T> Namespace LogicEngine Assembly LogicEngine.dll public record CompiledRule<T> : IAppliable<T>, IDetailedAppliable<T, string>, IEquatable<CompiledRule<T>> where T : new() Type Parameters T Inheritance object CompiledRule<T> Implements IAppliable<T> IDetailedAppliable<T, string> IEquatable<CompiledRule<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompiledRule(Func<T, bool>, string) Creates a new compiled rule public CompiledRule(Func<T, bool> executable, string code) Parameters executable Func<T, bool> code string Properties Code The code that represents the rule public string Code { get; } Property Value string Methods Apply(T) Applies the rule to an item public bool Apply(T item) Parameters item T Returns bool DetailedApply(T) Applies the rule to an item and returns either a string (the code if the rule is not satified) or a unit public Either<string, Unit> DetailedApply(T item) Parameters item T Returns Either<string, Unit>"
  },
  "api/LogicEngine.CompiledRulesSet-1.html": {
    "href": "api/LogicEngine.CompiledRulesSet-1.html",
    "title": "Class CompiledRulesSet<T> | Logic Engine",
    "keywords": "Class CompiledRulesSet<T> Namespace LogicEngine Assembly LogicEngine.dll public record CompiledRulesSet<T> : IAppliable<T>, IDetailedAppliable<T, IEnumerable<string>>, IAppliedSelector<T, string>, IEquatable<CompiledRulesSet<T>> where T : new() Type Parameters T Inheritance object CompiledRulesSet<T> Implements IAppliable<T> IDetailedAppliable<T, IEnumerable<string>> IAppliedSelector<T, string> IEquatable<CompiledRulesSet<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompiledRulesSet(CompiledRule<T>[], string) Creates a new compiled rules set public CompiledRulesSet(CompiledRule<T>[] rules, string name) Parameters rules CompiledRule<T>[] name string Properties Name public string Name { get; } Property Value string Methods Apply(T) Applies the rules set to an item public bool Apply(T item) Parameters item T Returns bool DetailedApply(T) Applies the rules set to an item and returns either a list of strings (the codes of the rules that are not satisfied) or a unit public Either<IEnumerable<string>, Unit> DetailedApply(T item) Parameters item T Returns Either<IEnumerable<string>, Unit> FirstMatching(T) Returns the code of the first rule that is satisfied by the item, None if no rule is satisfied public Option<string> FirstMatching(T item) Parameters item T Returns Option<string>"
  },
  "api/LogicEngine.Compilers.RuleCompiler.html": {
    "href": "api/LogicEngine.Compilers.RuleCompiler.html",
    "title": "Class RuleCompiler | Logic Engine",
    "keywords": "Class RuleCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RuleCompiler : IRuleCompiler Inheritance object RuleCompiler Implements IRuleCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Compile<T>(Rule) Compiles a given Rule into a CompiledRule<T>. It transforms the rule into a lambda expression, compiles it into a function, and wraps it in a CompiledRule<T> object. The method returns an Option, which contains the compiled rule if the compilation is successful, or None if it fails public Option<CompiledRule<T>> Compile<T>(Rule rule) where T : new() Parameters rule Rule Returns Option<CompiledRule<T>> Type Parameters T"
  },
  "api/LogicEngine.Compilers.RulesCatalogCompiler.html": {
    "href": "api/LogicEngine.Compilers.RulesCatalogCompiler.html",
    "title": "Class RulesCatalogCompiler | Logic Engine",
    "keywords": "Class RulesCatalogCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RulesCatalogCompiler : IRulesCatalogCompiler Inheritance object RulesCatalogCompiler Implements IRulesCatalogCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesCatalogCompiler(IRulesSetCompiler) public RulesCatalogCompiler(IRulesSetCompiler rulesSetCompiler) Parameters rulesSetCompiler IRulesSetCompiler Methods Compile<T>(RulesCatalog) ompiles a RulesCatalog into a CompiledCatalog<T>. It filters out any null RulesSets, compiles each valid RulesSet using the IRulesSetCompiler, and then constructs a CompiledCatalog<T> with the compiled rule sets and the catalog's name. The result is wrapped in an Option to handle cases where no valid rule sets are present. public Option<CompiledCatalog<T>> Compile<T>(RulesCatalog catalog) where T : new() Parameters catalog RulesCatalog Returns Option<CompiledCatalog<T>> Type Parameters T"
  },
  "api/LogicEngine.Compilers.RulesSetCompiler.html": {
    "href": "api/LogicEngine.Compilers.RulesSetCompiler.html",
    "title": "Class RulesSetCompiler | Logic Engine",
    "keywords": "Class RulesSetCompiler Namespace LogicEngine.Compilers Assembly LogicEngine.dll public class RulesSetCompiler : IRulesSetCompiler Inheritance object RulesSetCompiler Implements IRulesSetCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesSetCompiler(IRuleCompiler) public RulesSetCompiler(IRuleCompiler singleRuleCompiler) Parameters singleRuleCompiler IRuleCompiler Methods Compile<T>(RulesSet) Compiles a given RulesSet into an TinyFp.Option<A> of CompiledRulesSet<T> by compiling each individual rule in the set using the IRuleCompiler, filtering out any invalid rules, and then creating a new CompiledRulesSet<T> with the valid compiled rules and the original set's name. If no rules are valid, it returns None. public Option<CompiledRulesSet<T>> Compile<T>(RulesSet set) where T : new() Parameters set RulesSet Returns Option<CompiledRulesSet<T>> Type Parameters T"
  },
  "api/LogicEngine.Compilers.html": {
    "href": "api/LogicEngine.Compilers.html",
    "title": "Namespace LogicEngine.Compilers | Logic Engine",
    "keywords": "Namespace LogicEngine.Compilers Classes RuleCompiler RulesCatalogCompiler RulesSetCompiler"
  },
  "api/LogicEngine.Extensions.EnumerableExtensions.html": {
    "href": "api/LogicEngine.Extensions.EnumerableExtensions.html",
    "title": "Class EnumerableExtensions | Logic Engine",
    "keywords": "Class EnumerableExtensions Namespace LogicEngine.Extensions Assembly LogicEngine.dll public static class EnumerableExtensions Inheritance object EnumerableExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Filter<T>(IEnumerable<T>, IAppliable<T>) Filters the collection based on a given IAppliable<T> implementation. It returns only the elements on which Apply(T) returns true public static IEnumerable<T> Filter<T>(this IEnumerable<T> enumerable, IAppliable<T> app) where T : new() Parameters enumerable IEnumerable<T> app IAppliable<T> Returns IEnumerable<T> Type Parameters T FirstOrDefault<T>(IEnumerable<T>, IAppliable<T>) Takes an IAppliable<T> instance and returns the first element in the collection that satisfies the condition defined by Apply(T). If no such element is found, it returns the default value for the type T public static T FirstOrDefault<T>(this IEnumerable<T> @this, IAppliable<T> app) where T : new() Parameters this IEnumerable<T> app IAppliable<T> Returns T Type Parameters T"
  },
  "api/LogicEngine.Extensions.html": {
    "href": "api/LogicEngine.Extensions.html",
    "title": "Namespace LogicEngine.Extensions | Logic Engine",
    "keywords": "Namespace LogicEngine.Extensions Classes EnumerableExtensions"
  },
  "api/LogicEngine.Interfaces.Compilers.IRuleCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRuleCompiler.html",
    "title": "Interface IRuleCompiler | Logic Engine",
    "keywords": "Interface IRuleCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRuleCompiler Methods Compile<T>(Rule) Compiles a rule into a compiled rule, None if the rule is invalid Option<CompiledRule<T>> Compile<T>(Rule rule) where T : new() Parameters rule Rule Returns Option<CompiledRule<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.IRulesCatalogCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRulesCatalogCompiler.html",
    "title": "Interface IRulesCatalogCompiler | Logic Engine",
    "keywords": "Interface IRulesCatalogCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRulesCatalogCompiler Methods Compile<T>(RulesCatalog) Compiles a catalog of rules into a compiled catalog, None if the catalog is invalid Option<CompiledCatalog<T>> Compile<T>(RulesCatalog catalog) where T : new() Parameters catalog RulesCatalog Returns Option<CompiledCatalog<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.IRulesSetCompiler.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.IRulesSetCompiler.html",
    "title": "Interface IRulesSetCompiler | Logic Engine",
    "keywords": "Interface IRulesSetCompiler Namespace LogicEngine.Interfaces.Compilers Assembly LogicEngine.dll public interface IRulesSetCompiler Methods Compile<T>(RulesSet) Compiles a rule set into a compiled rule set, None if the rule set is invalid Option<CompiledRulesSet<T>> Compile<T>(RulesSet set) where T : new() Parameters set RulesSet Returns Option<CompiledRulesSet<T>> Type Parameters T"
  },
  "api/LogicEngine.Interfaces.Compilers.html": {
    "href": "api/LogicEngine.Interfaces.Compilers.html",
    "title": "Namespace LogicEngine.Interfaces.Compilers | Logic Engine",
    "keywords": "Namespace LogicEngine.Interfaces.Compilers Interfaces IRuleCompiler IRulesCatalogCompiler IRulesSetCompiler"
  },
  "api/LogicEngine.Interfaces.IAppliable-1.html": {
    "href": "api/LogicEngine.Interfaces.IAppliable-1.html",
    "title": "Interface IAppliable<T> | Logic Engine",
    "keywords": "Interface IAppliable<T> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IAppliable<in T> where T : new() Type Parameters T Methods Apply(T) Applies the item to the appliable bool Apply(T item) Parameters item T Returns bool"
  },
  "api/LogicEngine.Interfaces.IAppliedSelector-2.html": {
    "href": "api/LogicEngine.Interfaces.IAppliedSelector-2.html",
    "title": "Interface IAppliedSelector<TIn, TOut> | Logic Engine",
    "keywords": "Interface IAppliedSelector<TIn, TOut> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IAppliedSelector<TIn, TOut> where TIn : new() Type Parameters TIn TOut Methods FirstMatching(TIn) Returns the first matching item Option<TOut> FirstMatching(TIn item) Parameters item TIn Returns Option<TOut>"
  },
  "api/LogicEngine.Interfaces.IDetailedAppliable-2.html": {
    "href": "api/LogicEngine.Interfaces.IDetailedAppliable-2.html",
    "title": "Interface IDetailedAppliable<T, TOut> | Logic Engine",
    "keywords": "Interface IDetailedAppliable<T, TOut> Namespace LogicEngine.Interfaces Assembly LogicEngine.dll public interface IDetailedAppliable<T, TOut> where T : new() Type Parameters T TOut Methods DetailedApply(T) Applies the item to the appliable Either<TOut, Unit> DetailedApply(T item) Parameters item T Returns Either<TOut, Unit>"
  },
  "api/LogicEngine.Interfaces.html": {
    "href": "api/LogicEngine.Interfaces.html",
    "title": "Namespace LogicEngine.Interfaces | Logic Engine",
    "keywords": "Namespace LogicEngine.Interfaces Interfaces IAppliable<T> IAppliedSelector<TIn, TOut> IDetailedAppliable<T, TOut>"
  },
  "api/LogicEngine.Internals.OperatorType.html": {
    "href": "api/LogicEngine.Internals.OperatorType.html",
    "title": "Enum OperatorType | Logic Engine",
    "keywords": "Enum OperatorType Namespace LogicEngine.Internals Assembly LogicEngine.dll public enum OperatorType Fields Contains = 11 Item parameter contains specified constant ContainsKey = 15 Item parameter dictionary property contains the given key ContainsValue = 17 Item parameter dictionary property contains the given value Equal = 1 Item parameter is equal to specified constant GreaterThan = 6 Item parameter greater than specified constant GreaterThanOrEqual = 7 Item parameter greater or equal than specified constant InnerContains = 29 Item parameter array contains another item parameter InnerEqual = 23 Item parameter equal to another item parameter InnerGreaterThan = 24 Item parameter greater than another item parameter InnerGreaterThanOrEqual = 25 Item parameter greater or equal than another item parameter InnerLessThan = 26 Item parameter less than another item parameter InnerLessThanOrEqual = 27 Item parameter less or equal than another item parameter InnerNotContains = 30 Item parameter array does not contain another item parameter InnerNotEqual = 28 Item parameter not equal to another item parameter InnerNotOverlaps = 32 Item parameter array does not overlap another array parameter InnerOverlaps = 31 Item parameter array overlaps another array parameter IsContained = 21 Item parameter is contained into specified constant array IsNotContained = 22 Item parameter is not contained into specified constant array KeyContainsValue = 19 Item parameter dictionary has the given value for the specified key LessThan = 8 Item parameter less than specified constant LessThanOrEqual = 9 Item parameter less or equal than specified constant None = 0 NotContains = 12 Item parameter not contains specified constant NotContainsKey = 16 Item parameter dictionary property does not contain the given key NotContainsValue = 18 Item parameter dictionary property does not contain the given value NotEqual = 10 Item parameter not equal to specified constant NotKeyContainsValue = 20 Item parameter dictionary has not the given value for the specified key NotOverlaps = 14 Item parameter does not have intersections with specified enumerable constant Overlaps = 13 Item parameter has intersection with specified enumerable constant StringContains = 4 Item parameter string contains specified constant StringEndsWith = 3 Item parameter string ends with specified constant StringRegexIsMatch = 5 Item parameter string matches specified regex StringStartsWith = 2 Item parameter string starts with specified constant"
  },
  "api/LogicEngine.Internals.html": {
    "href": "api/LogicEngine.Internals.html",
    "title": "Namespace LogicEngine.Internals | Logic Engine",
    "keywords": "Namespace LogicEngine.Internals Enums OperatorType"
  },
  "api/LogicEngine.Models.Rule.html": {
    "href": "api/LogicEngine.Models.Rule.html",
    "title": "Class Rule | Logic Engine",
    "keywords": "Class Rule Namespace LogicEngine.Models Assembly LogicEngine.dll public record Rule : IEquatable<Rule> Inheritance object Rule Implements IEquatable<Rule> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Rule(string, OperatorType, string, string) public Rule(string property, OperatorType @operator, string value, string code) Parameters property string operator OperatorType value string code string Properties Code Code to return if the rule is not satisfied [DataMember(Name = \"code\")] public string Code { get; init; } Property Value string Operator Operator to apply to the property [DataMember(Name = \"operator\")] public OperatorType Operator { get; init; } Property Value OperatorType Property Name of the property the rule is applied to [DataMember(Name = \"property\")] public string Property { get; init; } Property Value string Value Value to compare the property to [DataMember(Name = \"value\")] public string Value { get; init; } Property Value string Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/LogicEngine.Models.RulesCatalog.html": {
    "href": "api/LogicEngine.Models.RulesCatalog.html",
    "title": "Class RulesCatalog | Logic Engine",
    "keywords": "Class RulesCatalog Namespace LogicEngine.Models Assembly LogicEngine.dll public record RulesCatalog : IEquatable<RulesCatalog> Inheritance object RulesCatalog Implements IEquatable<RulesCatalog> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesCatalog(IEnumerable<RulesSet>, string) Creates a new rules catalog public RulesCatalog(IEnumerable<RulesSet> rulesSets, string name) Parameters rulesSets IEnumerable<RulesSet> name string Properties Name public string Name { get; } Property Value string RulesSets Rules sets that make up the catalog public IEnumerable<RulesSet> RulesSets { get; } Property Value IEnumerable<RulesSet> Operators operator +(RulesCatalog, RulesCatalog) This represents the logical OR between two catalogs public static RulesCatalog operator +(RulesCatalog catalog1, RulesCatalog catalog2) Parameters catalog1 RulesCatalog catalog2 RulesCatalog Returns RulesCatalog operator *(RulesCatalog, RulesCatalog) This represents the logical AND between two catalogs public static RulesCatalog operator *(RulesCatalog catalog1, RulesCatalog catalog2) Parameters catalog1 RulesCatalog catalog2 RulesCatalog Returns RulesCatalog"
  },
  "api/LogicEngine.Models.RulesSet.html": {
    "href": "api/LogicEngine.Models.RulesSet.html",
    "title": "Class RulesSet | Logic Engine",
    "keywords": "Class RulesSet Namespace LogicEngine.Models Assembly LogicEngine.dll public record RulesSet : IEquatable<RulesSet> Inheritance object RulesSet Implements IEquatable<RulesSet> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesSet(IEnumerable<Rule>, string) Creates a new rule set public RulesSet(IEnumerable<Rule> rules, string name) Parameters rules IEnumerable<Rule> name string Properties Name public string Name { get; } Property Value string Rules Rules that make up the set [DataMember(Name = \"rules\")] public IEnumerable<Rule> Rules { get; init; } Property Value IEnumerable<Rule> Operators operator *(RulesSet, RulesSet) Combines two rule sets into one public static RulesSet operator *(RulesSet set1, RulesSet set2) Parameters set1 RulesSet set2 RulesSet Returns RulesSet"
  },
  "api/LogicEngine.Models.html": {
    "href": "api/LogicEngine.Models.html",
    "title": "Namespace LogicEngine.Models | Logic Engine",
    "keywords": "Namespace LogicEngine.Models Classes Rule RulesCatalog RulesSet"
  },
  "api/LogicEngine.html": {
    "href": "api/LogicEngine.html",
    "title": "Namespace LogicEngine | Logic Engine",
    "keywords": "Namespace LogicEngine Classes CompiledCatalog<T> CompiledRule<T> CompiledRulesSet<T>"
  },
  "docs/logic-engine.html": {
    "href": "docs/logic-engine.html",
    "title": "Logic Engine | Logic Engine",
    "keywords": "Logic Engine Table of contents The Rule The Operators Direct operators Internal direct operators String direct operators Enumerable operators Internal enumerable operators Key-value operators Inverse enumerable operators Inverse enumerable operators The RulesSets The RulesCatalog The Algebraic model RulesSets product RulesCatalog sum RulesCatalog product Compilers and compiled objects Known limitations Breaking changes How to install the package The Rule The rule object represents the building block for the system. A rule is an abstraction for a function acting on the value of a type and returning a boolean response. DEFINITION: A Rule is satisfied by an item t of type T if the associated function f: T ──► bool returns true if f(t) is true. Given a type to be applied to, a rule is defined by a set of fields Property: identifies the property against which to execute the evaluation Operator: defines the operation to execute on the property Value: identifies the value against which the result of the operator on the property should be compared Code: the error code to be generated when the rules applied on an object fail (returns false) The Operators The Operator can assume different possible values depending on the Property it is applied to and on the value, the result should be compared to. Operators are classified based on the way they work and their behavior. The rules categorization is also influenced by some implementation details. Direct operators These operators directly compare the Property to the Value considered as a constant: Equal: equality on value types (strings, numbers, ...) NotEqual: inequality on value types (strings, numbers, ...) GreaterThan: only applies to numbers GreaterThanOrEqual: only applies to numbers LessThan: only applies to numbers LessThanOrEqual: only applies to numbers public class MyClass { public string StringProperty {get; set;} public int IntegerProperty {get; set;} } var stringRule = new Rule(\"StringProperty\", OperatorType.Equal, \"Some Value\", \"code 1\"); var integerRule = new Rule(\"IntegerProperty\", OperatorType.Equal, \"10\", \"code 2\"); var myObj = new MyClass { StringProperty = \"Some Value\", IntegerProperty = 11 } var result1 = stringRule.Apply(myObj); // returns true var result2 = integerRule.Apply(myObj); // returns false Sample rules with direct operators Internal direct operators Internal direct rules are similar to direct rules, but they are meant to be applied to values that are other fields of the same type; in this case, Value should correspond to the name of another field in the analyzed type: InnerEqual: equality between two value typed fields InnerNotEqual: equality between two value typed fields InnerGreaterThan: only applies when Property and Value are numbers InnerGreaterThanOrEqual: only applies when Property and Value are numbers InnerLessThan: only applies when Property and Value are numbers InnerLessThanOrEqual: only applies when Property and Value are numbers public class MyClass { public string StringProperty1 {get; set;} public string StringProperty2 {get; set;} public int IntegerProperty1 {get; set;} public int IntegerProperty2 {get; set;} } var stringRule = new Rule(\"StringProperty1\", OperatorType.InnerEqual, \"StringProperty2\", \"code 1\"); var integerRule = new Rule(\"IntegerProperty1\", OperatorType.InnerGreaterThan, \"IntegerProperty2\", \"code 2\"); Sample rules with internal direct operators String direct operators These rules are specific to strings: StringStartsWith: checks that the string in Property starts with Value StringEndsWith: checks that the string in Property ends with Value StringContains: checks that the string in Property contains Value StringRegexIsMatch: checks that the string in Property matches Value public class MyClass { public string StringProperty {get; set;} } var stringRule = new Rule(\"StringProperty\", OperatorType.StringStartsWith, \"start\", \"code 1\"); Sample rule with string direct operator Enumerable operators These rules apply to operands of generic enumerable type: Contains: checks that Property contains Value NotContains: checks that Property does not Value Overlaps: checks that Property has a non-empty intersection with Value NotOverlaps: checks that Property has an empty intersection with Value public class MyClass { public IEnumerable<string> StringEnumerableProperty {get; set;} } var rule1 = new Rule(\"StringEnumerableProperty\", OperatorType.Contains, \"value\", \"code 1\"); var rule2 = new Rule(\"StringEnumerableProperty\", OperatorType.Overlaps, \"value1,value2\", \"code 2\"); Sample rules with enumerable operators Internal enumerable operators These operators act on enumerable fields by comparing them against fields of the same type: InnerContains: checks that Property contains the value contained in the property Value InnerNotContains: checks that Property doesn't contain the value contained in the property Value InnerOverlaps: checks that Property has a non-empty intersection with the value contained in the property Value InnerNotOverlaps: checks that Property has an empty intersection with the value contained in the property Value public class MyClass { public IEnumerable<int> EnumerableProperty1 {get; set;} public IEnumerable<int> EnumerableProperty2 {get; set;} public int IntegerField {get; set;} } var rule1 = new Rule(\"EnumerableProperty1\", OperatorType.InnerContains, \"IntegerField\"); var rule2 = new Rule(\"EnumerableProperty1\", OperatorType.InnerOverlaps, \"EnumerableProperty2\"); Sample rules for internal enumerable operators Key-value operators These operators act on dictionary-like objects: ContainsKey: checks that the Property contains the specific key defined by the Value NotContainsKey: checks that the Property doesn't contain the specific key defined by the Value ContainsValue: checks that the dictionary Property contains a value defined by the Value NotContainsValue: checks that the dictionary Property doesn't contain a value defined by the Value KeyContainsValue: checks that the dictionary Property has a key with a specific value NotKeyContainsValue: checks that the dictionary Property doesn't have a key with a specific value public class MyClass { public IDictionary<string, int> DictProperty {get; set;} } var rule1 = new Rule(\"DictProperty\", OperatorType.ContainsKey, \"mykey\"); var rule2 = new Rule(\"DictProperty\", OperatorType.KeyContainsValue, \"mykey[myvalue]\"); sample rules for key-value enumerable operators Inverse enumerable operators These rules apply to scalars against enumerable fields: IsContained: checks that Property is contained in a specific set IsNotContained: checks that Property is not contained in a specific set public class MyClass { public int IntProperty {get; set;} } var rule1 = new Rule(\"IntProperty\", OperatorType.IsContained, \"1,2,3\"); Sample rules for inverse enumerable operators The RulesSets A RulesSet is a set of rules. From a functional point of view, it represents a boolean typed function composed by a set of functions on a given type. DEFINITION: A RulesSet is satisfied by an item t of type T if all the functions of the set are satisfied by t. A RulesSet corresponds to the logical AND operator on its rules. The RulesCatalog A RulesCatalog represents a set of RulesSet, and functionally corresponds to a boolean typed function composed by a set of sets of functions on a given type. DEFINITION: A RulesCatalog is satisfied by an item t of type T if at least one of its RulesSets is satisfied by t. A RulesCatalog corresponds to the logical OR operator on its RulesSets. The Algebraic model As discussed above, composite types RulesSet and RulesCatalog represent logical operations on the field of functions f: T ──► bool; it seems than possible to define an algebraic model defining the composition of different entities. RulesSets product DEFINITION: The product of two RulesSets is a new RulesSet, and its rules are a set of rules obtained by concatenating the rules of the two RulesSets rs1 = {r1, r2, r3} rs2 = {r4, r5} ──► rs1 * rs2 = {r1, r2, r3, r4, r5} product of two RulesSets RulesCatalog sum The sum of two RulesCatalog objects is a RulesCatalog with a set of RulesSet obtained by simply concatenating the two sets of RulesSet: c1 = {rs1, rs2, rs3} c2 = {rs4, rs5} ──► c1 + c2 = {rs1, rs2, rs3, rs4, rs5} sum of two RulesCatalog RulesCatalog product The product of two catalogs is a catalog with a set of all the RulesSet obtained concatenating a set of the first catalog with one of the second. c1 = {rs1, rs2, rs3} c2 = {rs4, rs5} ──► c1 * c2 = {(rs1*rs4), (rs1*rs5), (rs2*rs4), (rs2*rs5), (rs3*rs4), (rs3*rs5)} product of two RulesCatalog Compilers and compiled objects The RuleCompiler is the component that parses and compiles a Rule into executable code. Every rule becomes an Option<CompiledRule<T>>, where the None status of the option corresponds to a Rule that is not formally correct and hence cannot be compiled[^1]. A CompiledRule<T> is the actual portion of code that can be applied to an item of type T to provide a boolean result using its ApplyApply(T item) method. Sometimes the boolean result is not enough: when the rule is not satisfied it could be useful to understand the reason why it failed. For this reason, a dedicated Either<string, Unit> DetailedApply(T item) method returns Unit when the rule is satisfied, or a string (the rule code) in case of failure. Like the RuleCompiler, the RulesSetCompiler transforms a RulesSet into an Option<CompiledRulesSet<T>>. A CompiledRulesSet<T> can logically be seen as a set of compiled rules, hence, when applied to an item of type T it returns a boolean that is true if all the compiled rules return true on it. From a logical point of view, a CompiledRulesSet<T> represents the AND superposition of its CompiledRule<T>. The corresponding Either<string, Unit> DetailedApply(T item) method of the CompiledRulesSet<T> returns Unit when all the rules are satisfied, or the set of codes for the rules that are not. Finally, the RulesCatalogCompiler transforms a RulesCatalog into an Option<CompiledCatalog<T>>, where the None status represents a catalog that cannot be compiled. A CompiledCatalog<T> logically represents the executable code that applies a set of rule sets to an object of type T: the result of its application can be true if at least one set of rules returns true, otherwise false (this represents the logical OR composition operations on rules joined by a logical AND). Similar to the Either<string, Unit> DetailedApply(T item) of the CompiledRulesSet<T>, it can return Unit when at least one internal rule set returns Unit, otherwise the flattened set of all the codes for all the rules that don't successfully apply. Known limitations The current implementation of the rules system has some limitations: it is designed to work on plain objects (instances of classes, records, or structures) with an empty constructor rules can only be applied to 'first level members', no nesting is currently supported Breaking changes If you want to upgrade from a version < 3.0.0 to the latest version you will need to adapt your implementation to manage the breaking changes introduced. The main differences can be condensed in the removal of the managers: the entire logic is now completely captured by the compiled objects CompiledRule<T>, CompiledRulesSet<T>, CompiledCatalog<T>, without the need of external wrappers. This means that the typical workflow to update the library requires: getting the rules definition pass them to the appropriate compiler use the generated compiled objects to validate your objects according to the rules definition How to install the package If you are using nuget.org you can add the dependency in your project using dotnet add package logic-engine --version <version> To install the logic-engine library from GitHub's packages system please refer to the packages page. [^0]: from a technical perspective this is obtained with a concrete implementation of the railway pattern [^1]: null or empty codes are removed because they don't carry reusable info"
  },
  "index.html": {
    "href": "index.html",
    "title": "| Logic Engine",
    "keywords": "version 4.1.0 The logic-engine is a lightweight .NET library designed to facilitate dynamic and flexible logic systems. It allows developers to define a generic set of rules that can be compiled into executable code, enabling modifications to business logic without altering the system's core. By leveraging functional programming principles (thanks to Franco Melandri's Tiny FP), it offers tools to evaluate whether an entity satisfies specific conditions and, if not, identify the reasons for failure. Key components include Rules, which are basic logical constructs, RulesSets for combined conditions using logical AND, and RulesCatalog for broader combinations using logical OR. It supports a wide range of operators, from comparisons (e.g., equality, greater-than, etc.) to more complex string and enumerable operations. The library aims to simplify logic handling while maintaining flexibility and clarity in implementation."
  }
}